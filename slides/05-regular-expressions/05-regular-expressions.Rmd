---
title: "Data Wrangling - 5. Regular Expressions"
author: "Kieran Healy"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    chakra: "../libs/remark-latest.min.js"
    css: ["default", "../css/kjh-slides.css", "../css/kjh-fonts.css", "../css/animate.css", "../css/widths.css"]
    seal: false
    anchor_sections: false
    nature:
      beforeInit: "../js/kjh-macros.js"
      highlightStyle: default
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%"
      ratio: "16:9"
      navigation:
        scroll: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
## Graphics options and theme-matching
source(here::here("slides", "R", "ragg_and_theme.R"))
```

```{r packages-data, include=FALSE}
library(flipbookr)
```

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view"))
xaringanExtra::use_animate_css()
xaringanExtra::use_animate_all("fade")
xaringanExtra::use_clipboard()
```

class: center middle main-title section-title-1

# A brief introduction to .kjh-yellow[regular expressions] 

.class-info[

**Data Wrangling: Session 5**

.light[Kieran Healy<br>
Statistical Horizons, April 2022]

]

---

layout: true
class: title title-1

---

# Load the packages, as always

.SMALL[
```{r 05-regular-expressions-1, message = FALSE}
library(here)      # manage file paths
library(socviz)    # data and some useful functions
```
]

.SMALL[

```{r 05-regular-expressions-2, message = TRUE}
library(tidyverse) # your friend and mine
library(gapminder) # gapminder data
library(stringr)
```
]

---


layout: false
class: center

# .middle.squish4.huge[.kjh-blue[Regular]<br />.kjh-blue[Expressions]]

_Or_, waiter, there appears to be a language inside my language

---

layout: true
class: title title-1

---

# .kjh-yellow[stringr] is your gateway to regexps

```{r 05-regular-expressions-3}
library(stringr)
```

Part of the tidyverse, but not loaded by default.

---

# .kjh-orange[regexps] are their own whole world

.pull-left[

![:scale 70%](img/regular_expressions_cover.png)
]

.pull-right[

This book is a thing of beauty.

]

---


# Searching for patterns

.normal.w75[A regular expression is a way of searching for a piece of text, or _pattern_, inside some larger body of text, called a _string_.] 

--

.normal.w75[The simplest sort of search is like the "Find" functionality in a Word Processor, where the pattern is a literal letter, number, punctuation mark, word or series of words and the text is a document that gets searched one line at a time. The next step up is "Find and Replace".]

--

.normal.w75[Every pattern-searching function in `stringr` has the same basic form:]

```r
str_view(<STRING>, <PATTERN>, [...]) # where [...] means "maybe some options"
```

--

.normal.w75[Functions that _replace_ as well as _detect_ strings all have this form:]

```r
str_replace(<STRING>, <PATTERN>, <REPLACEMENT>)
```

--

.small.squish3[(If you think about it, .kjh-orange[`<STRING>`], .kjh-orange[`<PATTERN>`] and .kjh-orange[`<REPLACEMENT>`] above are all kinds of pattern: they are meant to "stand for" all kinds of text, not be taken literally.)]

---

# Searching for patterns

.SMALL[Here I'll follow the exposition in Wickham & Grolemund (2017).]

```{r 05-regular-expressions-4}
x <- c("apple", "banana", "pear")

str_view(x, "an")
```

---

# Searching for patterns


.pull-left.w80[- Regular expressions get their real power from _wildcards_, i.e. tokens that match more than just literal strings, but also more general and more complex patterns.]

--

- The most general pattern-matching token is, "Match everything!" This is represented by the period, or **`.`**]

--

- But ... if “**`.`**” matches any character, how do you specifically match the character “.kjh-pink[**`.`**]”?

---

# Escaping

You have to "escape" the period to tell the regex you want to match it exactly, rather than interpret it as meaning "match anything".

--

regexs use the backslash, **\**, to signal "escape the next character".

--

To match a "**.**", you need the regex "**`\.`**"

???

You need to use an “escape” to tell the regular expression you want to match it exactly, not use its special behaviour. Like strings, regexs use the backslash, \, to escape special behaviour. So to match an ., you need the regex \.. Unfortunately this creates a problem. We use strings to represent regular expressions, and \ is also used as an escape symbol in strings. So to create the regular expression \. we need the string "\\.".

---

# Hang on, I see a further problem

.small.squish3[We use strings to represent regular expressions. **`\`** is also used as an escape symbol in strings. So to create the regular expression **`\.`** we need the string "**`\\.`**"]

```{r 05-regular-expressions-5}
# To create the regular expression, we need \\
dot <- "\\."

# But the expression itself only contains one:
writeLines(dot)

# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
```

???

We use strings to represent regular expressions, and \ is also used as an escape symbol in strings. So to create the regular expression \. we need the string "\\."

---
  
# But ... then how do you match a .kjh-yellow[literal] .kjh-pink[**`\`**]?

```{r 05-regular-expressions-6}

x <- "a\\b"
writeLines(x)
#> a\b

str_view(x, "\\\\") # you need four!

```

---

# But ... then how do you match a .kjh-yellow[literal] .kjh-pink[**`\`**]?

This is the price we pay for having to express searches for patterns using a language containing these same characters, which we may also want to search for. 

---

# I _promise_ this will pay off

Use .kjh-pink[**`^`**] to match the start of a string.

Use .kjh-pink[**`$`**] to match the end of a string.

--

.pull-left[

```{r 05-regular-expressions-7}
x <- c("apple", "banana", "pear")
str_view(x, "^a")
```

]
--

.pull-right[

```{r 05-regular-expressions-8}
str_view(x, "a$")
```

]

---

# Matching start and end

To force a regular expression to only match a complete string, anchor it with both .kjh-pink[**`^ `**] and .kjh-pink[**`$`**]

--

.pull-left[

```{r 05-regular-expressions-9}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")

```

]

--

.pull-right[

```{r 05-regular-expressions-10}
str_view(x, "^apple$")
```
]

---

# Matching character classes

.kjh-pink[**`\d`**] matches any digit.

.kjh-pink[**`\s`**] matches any whitespace (e.g. space, tab, newline).

.kjh-pink[**`[abc]`**] matches a, b, or c.

.kjh-pink[**`[^abc]`**] matches anything except a, b, or c.

???

Remember, to create a regular expression containing \d or \s, you’ll need to escape the \ for the string, so you’ll type "\\d" or "\\s".

---

# Matching the .kjh-yellow[_special_] characters

Look for a literal character that normally has special meaning in a regex

.pull-left[
```{r 05-regular-expressions-11}

str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")

```
]

--

.pull-right[

```{r 05-regular-expressions-12}
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
```

]

???

This works for most (but not all) regex metacharacters: $ . | ? * + ( ) [ {. Unfortunately, a few characters have special meaning even inside a character class and must be handled with backslash escapes: ] \ ^ and -.

---

# Alternation

Use parentheses to make the precedence of .kjh-pink[**`|`**] clear:

```{r 05-regular-expressions-13}
str_view(c("groy", "grey", "griy", "gray"), "gr(e|a)y")
```

---

# Repeated patterns


.kjh-pink[**`?`**] is 0 or 1

.kjh-pink[**`+`**] is 1 or more

.kjh-pink[**`*`**] is 0 or more

```{r 05-regular-expressions-14}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
```

---

# Repeated patterns


.kjh-pink[**`?`**] is 0 or 1

.kjh-pink[**`+`**] is 1 or more

.kjh-pink[**`*`**] is 0 or more

```{r 05-regular-expressions-15}
str_view(x, "CC+")
```


---

# Repeated patterns


.kjh-pink[**`?`**] is 0 or 1

.kjh-pink[**`+`**] is 1 or more

.kjh-pink[**`*`**] is 0 or more

```{r 05-regular-expressions-16}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, 'C[LX]+')
```

---

# Exact numbers of repetitions

.kjh-pink[**`{n}`**] is exactly n

.kjh-pink[**`{n,}`**] is n or more

.kjh-pink[**`{,m}`**] is at most m

.kjh-pink[**`{n,m}`**] is between n and m


```{r 05-regular-expressions-17}
str_view(x, "C{2}")
```


---

# Exact numbers of repetitions

.kjh-pink[**`{n}`**] is exactly n

.kjh-pink[**`{n,}`**] is n or more

.kjh-pink[**`{,m}`**] is at most m

.kjh-pink[**`{n,m}`**] is between n and m


```{r 05-regular-expressions-18}
str_view(x, "C{2,}")
```

___

# Exact numbers of repetitions

.kjh-pink[**`{n}`**] is exactly n

.kjh-pink[**`{n,}`**] is n or more

.kjh-pink[**`{,m}`**] is at most m

.kjh-pink[**`{n,m}`**] is between n and m


```{r 05-regular-expressions-19}
str_view(x, "C{2,3}")
```

___

# Exact numbers of repetitions

.kjh-pink[**`{n}`**] is exactly n

.kjh-pink[**`{n,}`**] is n or more

.kjh-pink[**`{,m}`**] is at most m

.kjh-pink[**`{n,m}`**] is between n and m


By default these are _greedy_ matches. You can make them “lazy”, matching the shortest string possible by putting a **`?`** after them. **This is often very useful!**

```{r 05-regular-expressions-20}
str_view(x, 'C{2,3}?')
```

---

# Exact numbers of repetitions

.kjh-pink[**`{n}`**] is exactly n

.kjh-pink[**`{n,}`**] is n or more

.kjh-pink[**`{,m}`**] is at most m

.kjh-pink[**`{n,m}`**] is between n and m

By default these are _greedy_ matches. You can make them “lazy”, matching the shortest string possible by putting a **`?`** after them. **This is often very useful!**

```{r 05-regular-expressions-21}
str_view(x, 'C[LX]+?')
```

---

# And .kjh-yellow[finally] ... backreferences


```{r 05-regular-expressions-22}
fruit # built into stringr
```

---

# Grouping and backreferences

Find all fruits that have a repeated pair of letters:

```{r 05-regular-expressions-23}
str_view(fruit, "(..)\\1", match = TRUE)
```

---

# Grouping and backreferences

Backreferences and grouping will be very useful for string _replacements_.

---

# OK that was a .kjh-red[lot]

.center[![:scale 80%](img/grover_bluehead.jpg)]

---

# Learning .kjh-yellow[and testing] regexps

Practice with a tester like [https://regexr.com](https://regexr.com)

Or an app like [Patterns](https://krillapps.com/patterns/)

The regex engine or "flavor" used by `stringr` is Perl- or PCRE-like. 

---

# What was the point of that?

We use basic or slightly fancy regexps _very often_ when importing and cleaning data.

--

As we'll soon see! It's time to read in a bunch of data.
