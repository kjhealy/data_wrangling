---
title: "Data Wrangling - 3B. Manipulating tables with `dplyr`"
author: "Kieran Healy"
date: ".kjh-green[**`r Sys.Date()`**]"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    chakra: "../libs/remark-latest.min.js"
    css: ["default", "../css/kjh-slides.css", "../css/kjh-fonts.css", "../css/animate.css", "../css/widths.css"]
    seal: false
    anchor_sections: false
    nature:
      beforeInit: "../js/kjh-macros.js"
      highlightStyle: default
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%"
      ratio: "16:9"
      navigation:
        scroll: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
## Graphics options and theme-matching
source(here::here("slides", "R", "ragg_and_theme.R"))
ggplot2::theme_set(theme_solitas())
```

```{r packages-data, include=FALSE}
library(flipbookr)
# library(cowplot)
# ggplot2::theme_set(theme_cowplot())

```

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view"))
xaringanExtra::use_animate_css()
xaringanExtra::use_animate_all("fade")
xaringanExtra::use_clipboard()
```

class: center middle main-title section-title-1

# Manipulating Tables with .kjh-yellow[dplyr] (contd)

.class-info[

**Data Wrangling: Session 3**

.light[Kieran Healy<br>
Statistical Horizons, April 2022]

]

---

layout: false
class: center

# .huge.middle.squish4[.kjh-orange[Window functions] and .kjh-green[moving averages]]

---

layout: true
class: title title-1

---

# Load our libraries

.SMALL[
```{r 03-dplyr-basics-1, message = TRUE}
library(here)      # manage file paths
library(socviz)    # data and some useful functions
library(tidyverse) # your friend and mine
```
]

---

# `dplyr`'s .kjh-yellow[window] functions 

Ranking and cumulation within groups.  


```{r 03-dplyr-basics-48}
## Data on COVID-19
library(covdata)

covnat_weekly 
```

---

# `dplyr`'s .kjh-yellow[window] functions 

.kjh-green[**`cumsum()`**] gives cumulative sums

```{r 03-dplyr-basics-49}
covnat_weekly %>% 
  filter(iso3 == "USA") %>% 
  select(date, cname, iso3, cases) %>% 
  mutate(cumulative = cumsum(cases)) 

```

---

# `dplyr`'s .kjh-yellow[window] functions 

.SMALL[.kjh-green[**`cume_dist()`**] gives the proportion of values less than or equal to the current value.]

```{r 03-dplyr-basics-50}
covnat_weekly %>% 
  select(date, cname, iso3, deaths) %>% 
  filter(iso3 == "USA") %>% 
  filter(cume_dist(desc(deaths)) < 0.1) # i.e. Top 10%

```

.SMALL.squish3[The `dplyr` vignette on Window functions is good.] 

---

# An application 

```{r 03-dplyr-basics-51}
covus %>% 
  filter(measure == "death") %>% 
  group_by(state) %>% 
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
```

.SMALL.squish3[Here the `count` measure is _cumulative_ deaths. What if we want to recover the daily count for all the states in the data?]

---

# An application 

.kjh-green[**`dplyr` has `lead()`**] and .kjh-green[**`lag()`**] functions. These allow you to access the previous and next values in a vector. You can calculate offsets this way.

```{r 03-dplyr-basics-52}
my_vec <- c(1:20)
my_vec
lag(my_vec) # first element has no lag

my_vec - lag(my_vec)

```

---

# An application

.SMALL.squish3[We can write the expression directly:]

.SMALL[
```{r 03-dplyr-basics-53}
covus %>%
  select(-data_quality_grade) %>% 
  filter(measure == "death") %>%
  group_by(state) %>%
  arrange(date) %>% 
  mutate(deaths_daily = count - lag(count, order_by = date)) %>% 
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
  
```
]
---

# Writing our own .kjh-orange[functions]

But we could also write a function to do this. 

We write functions using the special .kjh-green[**`function()`**] function.\*

.SMALL[

```{r 03-dplyr-basics-54}
my_fun <- function(x) {
  x + 1
}

my_fun # we've created the function; it's just an object

my_fun(x = 1) # But we can supply it with an input!

my_fun(10)
```

]

.smaller[.footnote[.kjh-darkgrey[\*Nerds love this sort of stuff.]]]

---

# Writing our own .kjh-orange[functions]

We write our function. It's just the expression we originally wrote, wrapped up.

```{r 03-dplyr-basics-55}
get_daily_count <- function(count, date){
  count - lag(count, order_by = date)
}
```

This function has no generality, error-handling, or anything else. It's a once-off.

---

# Writing our own .kjh-orange[functions]

.SMALL.squish3[Now we can use it like any other:]

.SMALL[
```{r 03-dplyr-basics-56}
covus %>%
  filter(measure == "death") %>%
  select(-data_quality_grade) %>% 
  group_by(state) %>%
  arrange(date) %>% 
  mutate(deaths_daily = get_daily_count(count, date)) %>% 
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
  
```
]

.SMALL.squish3[Not super-useful quite yet, but if our task had more steps ...]

---

# Tidy moving averages with .kjh-orange[`slider`]  

`dplyr`'s window functions don't include moving averages. 

There are several options, notably [`RcppRoll`](https://cran.r-project.org/web/packages/RcppRoll/index.html)

We'll use the .kjh-orange[[`slider`](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)] package.

```{r 03-dplyr-basics-57}
# install.packages("slider")
library(slider)
```

---

# Tidy moving averages with .kjh-orange[`slider`]  

.SMALL[

```{r 03-dplyr-basics-58}
covus %>%
  filter(measure == "death") %>%
  select(-data_quality_grade) %>% 
  group_by(state) %>%
  arrange(date) %>% 
  mutate(
    deaths_daily = get_daily_count(count, date), 
    deaths7 = slide_mean(deaths_daily, #<<
                         before = 7, #<<
                         na_rm = TRUE)) %>% #<<
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
```

]
---

# Tidy moving averages with .kjh-orange[`slider`]  

```r
    deaths7 = slide_mean(deaths_daily, #<<
                         before = 7, #<<
                         na_rm = TRUE)) %>% #<<
```

.SMALL[

Notice the Tidyverse-style `na_rm` argument rather than the usual base `na.rm`

The package provides a lot of different functions, from general-purpose .kjh-green[**`slide_max()`**], .kjh-green[**`slide_min()`**] to more specialized sliding functions. In particular note e.g. .kjh-green[**`slide_index_mean()`**] that addresses some subtleties in averaging over dates with gaps. 
]

---

# Tidy up after yourself with .kjh-green[**`relocate()`**]

```{r 03-dplyr-basics-59}
gss_sm
```

---

```{r 03-relocate-pipeline, include = FALSE}
gss_sm %>% 
  select(region, bigregion, year, 
         id:region, 
         starts_with("p"), 
         contains("income")) %>% 
  rename(children = childs, 
         siblings = sibs) %>% 
  relocate(id) %>% 
  select(-ballot) %>% 
  relocate(where(is.numeric), 
           .before = where(is.factor)) %>% 
  relocate(contains("region"), 
           .after = year) 
```

`r chunk_reveal("03-relocate-pipeline", widths = c(35,65), title = "# Shuffle columns around")`


---

layout: false
class: center

# .middle.squish4.large[Two dplyr .kjh-red[gotchas]]

---

layout: true
class: title title-1

---

# Comparisons filtering on proportions

Let's say you are working with proportions

```{r, echo = FALSE}

# Make some sample data with tribb
df <- tribble(~id, ~ prop1, ~prop2,
              "A", 0.1,      0.2,
              "B", 0.1,      0.21, 
              "C", 0.11,     0.2,
              "D", 0.1,      0.1)
```

```{r}
df
```

---

# Comparisons filtering on proportions

And you want to focus on cases where `prop1` _plus_ `prop2` is greater than 0.3:

--

```{r}
df %>% 
  filter(prop1 + prop2 > 0.3)
```

`A` shouldn't have been included there.

--

This is not dlpyr's fault. It's our floating point friend again.

---

# Comparisons filtering on proportions


```{r}
df %>% 
  filter(prop1 + prop2 == 0.3)
```

`A` _should_ have been included here!

---

# Comparisons filtering on proportions

This won't give the right behavior either:

```{r}
df %>% 
  mutate(prop3 = prop1 + prop2) %>% 
  filter(prop3 == 0.3)
```

---

# Comparisons filtering on proportions

So, beware.

```{r}
df %>% 
  filter(prop1*100 + prop2*100 == 0.3*100)
```

Better:

```{r}
df %>% 
  filter(near(prop1 + prop2, 0.3))
```

---

# .kjh-orange[Zero Counts] in dplyr

```{r}
df <- read_csv(here("data", "first_terms.csv"))

df
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r, echo = FALSE}
## Hex colors for sex
sex_colors <- c("#E69F00", "#993300")

## Group labels
mf_labs <- tibble(M = "Men", F = "Women")

theme_set(cowplot::theme_cowplot())

```


```{r}
df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N))

```

---

#  .kjh-orange[Zero Counts] in dplyr


```{r}
p_col <- df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N)) %>%
    ggplot(aes(x = start_year,
               y = freq,
               fill = sex)) +
    geom_col() +
    scale_y_continuous(labels = scales::percent) +
    scale_fill_manual(values = sex_colors, labels = c("Women", "Men")) +
    labs(x = "Year", y = "Percent", fill = "Group") +
    facet_wrap(~ party)
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r, fig.height = 6, fig.width=10}
p_col
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r}
p_line <- df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N)) %>%
    ggplot(aes(x = start_year,
               y = freq,
               color = sex)) +
    geom_line(size = 1.1) +
    scale_y_continuous(labels = scales::percent) +
    scale_color_manual(values = sex_colors, labels = c("Women", "Men")) +
    guides(color = guide_legend(reverse = TRUE)) +
    labs(x = "Year", y = "Percent", color = "Group") +
    facet_wrap(~ party)
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r, fig.height = 6, fig.width=9}
p_line
```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

Factors are for categorical variables and are stored differently from characters.

This can matter when modeling, and also now.

```{r}
df_f <- df %>% 
  mutate(party_f = factor(party))

df_f
```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

```{r}
df_f %>% 
  group_by(party_f) %>% 
  tally()
```

Factors are integer values with named labels, or _levels_:

```{r}
typeof(df_f$party_f)
levels(df_f$party_f)

```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

By default, unused levels won't display:


```{r}
df_f <- df %>% 
  mutate(party_f = factor(party, 
                          levels = c("Democrat", 
                                     "Republican", 
                                     "Libertarian")))
df_f %>% 
  group_by(party_f) %>% 
  tally()

levels(df_f$party_f)

```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

By default, unused levels won't display:

```{r}
df %>% 
  mutate(across(where(is.character), as_factor)) %>% 
  group_by(start_year, party, sex) %>%
  summarize(N = n()) %>%
  mutate(freq = N / sum(N))

```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

You can make `dplyr` keep empty factor levels though:

```{r}
df %>% 
  mutate(across(where(is.character), as_factor)) %>% 
  group_by(start_year, party, sex, .drop = FALSE) %>% #<<
  summarize(N = n()) %>%
  mutate(freq = N / sum(N))
  
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]

Maybe you don't want to deal with factors.

```{r}
df_c <- df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N)) %>%
    ungroup() %>%#<<
    complete(start_year, party, sex,#<<
             fill = list(N = 0, freq = 0))#<<
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]


```{r}
df_c
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]

```{r}
p_out <- df_c %>% 
  ggplot(aes(x = start_year,
               y = freq,
               color = sex)) +
    geom_line(size = 1.1) +
    scale_y_continuous(labels = scales::percent) +
    scale_color_manual(values = sex_colors, labels = c("Women", "Men")) +
    guides(color = guide_legend(reverse = TRUE)) +
    labs(x = "Year", y = "Percent", color = "Group") +
    facet_wrap(~ party)
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]

```{r, fig.height = 6, fig.width=9}
p_out
```

