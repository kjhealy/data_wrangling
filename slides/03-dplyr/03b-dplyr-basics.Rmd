---
title: "Data Wrangling - 3B. Manipulating tables with `dplyr`"
author: "Kieran Healy"
date: "`r Sys.Date()`"
output: kjhslides::kjh_slides_reader
editor_options: 
  chunk_output_type: console
---


```{r packages, include=FALSE}
library(flipbookr)
library(here)
library(tidyverse)
library(kjhslides)
```


```{r setup, include=FALSE}

kjh_register_tenso()
kjh_set_knitr_opts()
kjh_set_slide_theme()
kjh_set_xaringan_opts()

```


class: center middle main-title section-title-1

# Manipulating Tables with .kjh-yellow[dplyr] (contd)

.class-info[

**Data Wrangling: Session 3**

.light[Kieran Healy<br>
Statistical Horizons, December 2022]

]

---

layout: false
class: center

# .huge.middle.squish4[.kjh-orange[Window functions] and .kjh-green[moving averages]]

---

layout: true
class: title title-1

---

# Load our libraries

.SMALL[
```{r 03b-dplyr-basics-2, message = TRUE}
library(here)      # manage file paths
library(socviz)    # data and some useful functions
library(tidyverse) # your friend and mine
```
]

---

# **`dplyr`**'s .kjh-yellow[window] functions 

Ranking and cumulation within groups.  


```{r 03b-dplyr-basics-3 }
## Data on COVID-19
library(covdata)

covnat_weekly 
```

---

# **`dplyr`**'s .kjh-yellow[window] functions 

.kjh-green[**`cumsum()`**] gives cumulative sums

```{r 03b-dplyr-basics-4 }
covnat_weekly %>% 
  filter(iso3 == "USA") %>% 
  select(date, cname, iso3, cases) %>% 
  mutate(cumulative = cumsum(cases)) 

```

---

# **`dplyr`**'s .kjh-yellow[window] functions 

.kjh-green[**`cume_dist()`**] gives the proportion of values less than or equal to the current value.

```{r 03b-dplyr-basics-5 }
covnat_weekly %>% 
  select(date, cname, iso3, deaths) %>% 
  filter(iso3 == "USA") %>% 
  filter(cume_dist(desc(deaths)) < 0.1) # i.e. Top 10%

```

.squish3[The `dplyr` vignette on Window functions is good.] 

---

# An application 

```{r 03b-dplyr-basics-6 }
covus %>% 
  filter(measure == "death") %>% 
  group_by(state) %>% 
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
```

.squish3[Here the `count` measure is _cumulative_ deaths. What if we want to recover the daily count for all the states in the data?]

---

# An application 

`dplyr` has .kjh-green[**`lead()`**] and .kjh-green[**`lag()`**] functions. These allow you to access the previous and next values in a vector. You can calculate offsets this way.

```{r 03b-dplyr-basics-7 }
my_vec <- c(1:20)
my_vec
lag(my_vec) # first element has no lag

my_vec - lag(my_vec)

```

---

# An application

.squish3[We can write the expression directly:]

```{r 03b-dplyr-basics-8 }
covus %>%
  select(-data_quality_grade) %>% 
  filter(measure == "death") %>%
  group_by(state) %>%
  arrange(date) %>% 
  mutate(deaths_daily = count - lag(count, order_by = date)) %>% 
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
  
```

---

# Writing our own .kjh-orange[functions]

But we could also write a function to do this. 

We write functions using the special .kjh-green[**`function()`**] function.\*


```{r 03b-dplyr-basics-9 }
my_fun <- function(x) {
  x + 1
}

my_fun # we've created the function; it's just an object

my_fun(x = 1) # But we can supply it with an input!

my_fun(10)
```



.smaller[.footnote[.kjh-darkgrey[\*Nerds love this sort of stuff.]]]

---

# Writing our own .kjh-orange[functions]

We write our function. It's just the expression we originally wrote, wrapped up.

```{r 03b-dplyr-basics-10 }
get_daily_count <- function(count, date){
  count - lag(count, order_by = date)
}
```

This function has no generality, error-handling, or anything else. It's a once-off.

---

# Writing our own .kjh-orange[functions]

.squish3[Now we can use it like any other:]

```{r 03b-dplyr-basics-11 }
covus %>%
  filter(measure == "death") %>%
  select(-data_quality_grade) %>% 
  group_by(state) %>%
  arrange(date) %>% 
  mutate(deaths_daily = get_daily_count(count, date)) %>% 
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
  
```


.squish3[Not super-useful quite yet, but if our task had more steps ...]

---

# Tidy moving averages with .kjh-orange[`slider`]  

**`dplyr`**'s window functions don't include moving averages. 

There are several options, notably [`RcppRoll`](https://cran.r-project.org/web/packages/RcppRoll/index.html)

We'll use the .kjh-orange[[`slider`](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)] package.

```{r 03b-dplyr-basics-12 }
# install.packages("slider")
library(slider)
```

---

# Tidy moving averages with .kjh-orange[`slider`]  

```{r 03b-dplyr-basics-13 }
covus %>%
  filter(measure == "death") %>%
  select(-data_quality_grade) %>% 
  group_by(state) %>%
  arrange(date) %>% 
  mutate(
    deaths_daily = get_daily_count(count, date), 
    deaths7 = slide_mean(deaths_daily, #<<
                         before = 7, #<<
                         na_rm = TRUE)) %>% #<<
  arrange(state, desc(date)) %>% 
  filter(state %in% "NY")
```


---

# Tidy moving averages with .kjh-orange[`slider`]  

```r
    deaths7 = slide_mean(deaths_daily, 
                         before = 7, 
                         na_rm = TRUE)) %>% 
```

.pull-left.w70[Notice the Tidyverse-style `na_rm` argument rather than the usual base `na.rm`]

.pull-left.w70[The package provides a lot of different functions, from general-purpose .kjh-green[**`slide_max()`**], .kjh-green[**`slide_min()`**] to more specialized sliding functions. In particular note e.g. .kjh-green[**`slide_index_mean()`**] that addresses some subtleties in averaging over dates with gaps. ]


---

# Tidy up after yourself with .kjh-green[**`relocate()`**]

```{r 03b-dplyr-basics-14 }
gss_sm
```

---

```{r 03b-dplyr-basics-15, include = FALSE}
gss_sm %>% 
  select(region, bigregion, year, 
         id:region, 
         starts_with("p"), 
         contains("income")) %>% 
  rename(children = childs, 
         siblings = sibs) %>% 
  relocate(id) %>% 
  select(-ballot) %>% 
  relocate(where(is.numeric), 
           .before = where(is.factor)) %>% 
  relocate(contains("region"), 
           .after = year) 
```

`r chunk_reveal("03b-dplyr-basics-15", widths = c(35,65), title = "# Shuffle columns around")`

---

# Recapping the Office Hour

```{r 03b-dplyr-basics-16 }
library(ukelection2019)

ukvote2019
```

---


# Recapping the Office Hour

Use .kjh-green[**`sample_n()`**] to sample `n` rows of your tibble.

```{r 03b-dplyr-basics-17 }
library(ukelection2019)

ukvote2019 %>% 
  sample_n(10)
```

---


# Recapping the Office Hour

- A vector of unique constituency names

```{r 03b-dplyr-basics-18}
ukvote2019 %>% 
  distinct(constituency)
```


---

# Recapping the Office Hour

- Tally them up

```{r 03b-dplyr-basics-19}
ukvote2019 %>% 
  distinct(constituency) %>% 
  tally()
```

```{r 03b-dplyr-basics-20}
# Base R / non-pipeline version

length(unique(ukvote2019$constituency))
```


---

# Recapping the Office Hour

```{r 03b-dplyr-basics-21}
ukvote2019 %>% 
  count(party_name) %>% 
  arrange(desc(n))
```

---

# Recapping the Office Hour

.pull-left[
- .SMALL.squish3[Top 5]
```{r 03b-dplyr-basics-22}
ukvote2019 %>% 
  count(party_name) %>% 
  slice_max(order_by = n, n = 5)

```
]

--

.pull-right[
- .SMALL.squish3[Bottom 5]
```{r 03b-dplyr-basics-23}
ukvote2019 %>% 
  count(party_name) %>% 
  slice_min(order_by = n, n = 5)

```
]


---

# Recapping the Office Hour


```{r 03b-dplyr-basics-24}
ukvote2019 %>% 
  count(constituency) 
```

---

# Counting Twice Over

```{r 03b-dplyr-basics-25}
ukvote2019 %>% 
  count(constituency) %>% 
  count(n)
```

---

```{r 03b-dplyr-basics-26, include = FALSE}
ukvote2019 %>% 
  count(constituency, name = "n_cands") %>% 
  count(n_cands, name = "n_const")
```

`r chunk_reveal("03b-dplyr-basics-26", widths = c(35,65), title = "# Counting Twice Over")`

---

layout: false
class: center

# .middle.squish4.large[Two dplyr .kjh-red[gotchas]]

---

layout: true
class: title title-1

---

# Comparisons filtering on proportions

Let's say you are working with proportions

```{r 03b-dplyr-basics-27, echo = FALSE}

# Make some sample data with tribb
df <- tribble(~id, ~ prop1, ~prop2,
              "A", 0.1,      0.2,
              "B", 0.1,      0.21, 
              "C", 0.11,     0.2,
              "D", 0.1,      0.1)
```

```{r 03b-dplyr-basics-28}
df
```

---

# Comparisons filtering on proportions

And you want to focus on cases where `prop1` _plus_ `prop2` is greater than 0.3:

--

```{r 03b-dplyr-basics-29}
df %>% 
  filter(prop1 + prop2 > 0.3)
```

The row with `id` .kjh-orange[**`A`**] shouldn't have been included there.

--

This is not dlpyr's fault. It's our floating point friend again.

---

# Comparisons filtering on proportions


```{r 03b-dplyr-basics-30}
df %>% 
  filter(prop1 + prop2 == 0.3)
```

The row with `id` .kjh-orange[**`A`**] _should_ have been included here!

---

# Comparisons filtering on proportions

This won't give the right behavior either:

```{r 03b-dplyr-basics-31}
df %>% 
  mutate(prop3 = prop1 + prop2) %>% 
  filter(prop3 == 0.3)
```

---

# Comparisons filtering on proportions

So, beware.

```{r 03b-dplyr-basics-32}
df %>% 
  filter(prop1*100 + prop2*100 == 0.3*100)
```

Better:

```{r 03b-dplyr-basics-33}
df %>% 
  filter(near(prop1 + prop2, 0.3))
```

---

# .kjh-orange[Zero Counts] in dplyr

```{r 03b-dplyr-basics-34}
df <- read_csv(here("data", "first_terms.csv"))

df
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r 03b-dplyr-basics-35, echo = FALSE}
## Hex colors for sex
sex_colors <- c("#E69F00", "#993300")

## Group labels
mf_labs <- tibble(M = "Men", F = "Women")

```


```{r 03b-dplyr-basics-36}
df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N))

```

---

#  .kjh-orange[Zero Counts] in dplyr


```{r 03b-dplyr-basics-37}
p_col <- df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N)) %>%
    ggplot(aes(x = start_year,
               y = freq,
               fill = sex)) +
    geom_col() +
    scale_y_continuous(labels = scales::percent) +
    scale_fill_manual(values = sex_colors, labels = c("Women", "Men")) +
    labs(x = "Year", y = "Percent", fill = "Group") +
    facet_wrap(~ party)
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r 03b-dplyr-basics-38, fig.height = 6, fig.width=10}
p_col
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r 03b-dplyr-basics-39}
p_line <- df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N)) %>%
    ggplot(aes(x = start_year,
               y = freq,
               color = sex)) +
    geom_line(size = 1.1) +
    scale_y_continuous(labels = scales::percent) +
    scale_color_manual(values = sex_colors, labels = c("Women", "Men")) +
    guides(color = guide_legend(reverse = TRUE)) +
    labs(x = "Year", y = "Percent", color = "Group") +
    facet_wrap(~ party)
```

---

#  .kjh-orange[Zero Counts] in dplyr

```{r 03b-dplyr-basics-40, fig.height = 6, fig.width=9}
p_line
```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

Factors are for categorical variables and are stored differently from characters.

This can matter when modeling, and also now.

```{r 03b-dplyr-basics-41}
df_f <- df %>% 
  mutate(party_f = factor(party))

df_f
```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

```{r 03b-dplyr-basics-42}
df_f %>% 
  group_by(party_f) %>% 
  tally()
```

Factors are integer values with named labels, or _levels_:

```{r 03b-dplyr-basics-43}
typeof(df_f$party_f)
levels(df_f$party_f)

```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

By default, unused levels won't display:


```{r 03b-dplyr-basics-44}
df_f <- df %>% 
  mutate(party_f = factor(party, 
                          levels = c("Democrat", 
                                     "Republican", 
                                     "Libertarian")))
df_f %>% 
  group_by(party_f) %>% 
  tally()

levels(df_f$party_f)

```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

By default, unused levels won't display:

```{r 03b-dplyr-basics-45}
df %>% 
  mutate(across(where(is.character), as_factor)) %>% 
  group_by(start_year, party, sex) %>%
  summarize(N = n()) %>%
  mutate(freq = N / sum(N))

```

---

# Option 1: .kjh-orange[factors] and .kjh-red[`.drop`]

You can make `dplyr` keep empty factor levels though:

```{r 03b-dplyr-basics-46}
df %>% 
  mutate(across(where(is.character), as_factor)) %>% 
  group_by(start_year, party, sex, .drop = FALSE) %>% #<<
  summarize(N = n()) %>%
  mutate(freq = N / sum(N))
  
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]

Maybe you don't want to deal with factors.

```{r 03b-dplyr-basics-47}
df_c <- df %>%
    group_by(start_year, party, sex) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N)) %>%
    ungroup() %>%#<<
    complete(start_year, party, sex,#<<
             fill = list(N = 0, freq = 0))#<<
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]


```{r 03b-dplyr-basics-48}
df_c
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]

```{r 03b-dplyr-basics-49}
p_out <- df_c %>% 
  ggplot(aes(x = start_year,
               y = freq,
               color = sex)) +
    geom_line(size = 1.1) +
    scale_y_continuous(labels = scales::percent) +
    scale_color_manual(values = sex_colors, labels = c("Women", "Men")) +
    guides(color = guide_legend(reverse = TRUE)) +
    labs(x = "Year", y = "Percent", color = "Group") +
    facet_wrap(~ party)
```

---

# Option 2: .kjh-green[ungroup()] and .kjh-green[complete()]

```{r 03b-dplyr-basics-50, fig.height = 6, fig.width=9}
p_out
```

