---
title: "Data Wrangling - 3. Manipulating tables with `dplyr`"
author: "Kieran Healy"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    chakra: "../libs/remark-latest.min.js"
    css: ["default", "../css/kjh-slides.css", "../css/kjh-inferno-fonts.css", "../css/animate.css"]
    seal: false
    anchor_sections: false
    nature:
      beforeInit: "../js/kjh-macros.js"
      highlightStyle: default
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
      navigation:
        scroll: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, 
                      fig.retina = 3, fig.align = "center")
```

```{r packages-data, include=FALSE}
library(flipbookr)
library(cowplot)
ggplot2::theme_set(theme_cowplot())

```

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view"))
xaringanExtra::use_animate_css()
xaringanExtra::use_animate_all("fade")
xaringanExtra::use_clipboard()
```

class: center middle main-title section-title-1

# Manipulating Tables with .kjh-yellow[`dplyr`]

.class-info[

**Session 3**

.light[Kieran Healy<br>
Statistical Horizons, April 2021]

]

---

layout: false
class: main-title main-title-inv

# .middle.squish4[Time to<br />play with<br />some .kjh-red[data]]

--

- woohoo!

---

layout: true
class: title title-1

---

# Load our libraries

.SMALL[
```{r, message = TRUE}
library(here)      # manage file paths
library(socviz)    # data and some useful functions
library(tidyverse) # your friend and mine
```
]

---

# Tidyverse components, again

.center[![:scale 100%](img/dplyr_1.png)]

---

# Tidyverse components, again

.center[![:scale 100%](img/dplyr_2.png)]

---

# Other tidyverse components

.center[![:scale 100%](img/dplyr_addnl_1.png)]

---

# Other tidyverse components

.center[![:scale 100%](img/dplyr_addnl_2.png)]


- Not all of these are attached when we do `library(tidyverse)`

---

# .kjh-yellow[dplyr] lets you work with tibbles

- Remember, tibbles are tables of data where the columns can be of different types, such as numeric, logical, character, factor, etc.

--

- We'll use dplyr to _transform_ and _summarize_ our data.

--

- We'll use the pipe operator, **`%>%`**, to chain together sequences of actions on our tables.

--

---

layout: false
class: main-title main-title-inv

# .middle.squish4[`dplyr` draws on the logic and language of  .kjh-green[database queries], where the focus is on manupulating tables]

---

layout: true
class: title title-1

---

# Some .kjh-orange[actions] to take on a single table 

--

- **Group** the data at the level we want, such as “_Religion by Region_” or _“Children by School by District_”, so as to present data at that level.

--

- **Subset** either the rows or columns of or table.

--

- **Mutate**  the data. That is, change something at the _current_ level of grouping.  Mutating adds new columns to the table, or changes the content of an existing column. This won't change the number of rows.

--

- **Summarize** or aggregate the data. That is, make something new at a _higher_ level of grouping. E.g., calculate means or counts by some grouping variable. This will generally result in a smaller, _summary_ table.

---

# Each .kjh-orange[action] has a corresponding .kjh-green[function] 

--

- **Group** using  `group_by()`.

--

- **Subset** has one action for rows and one for columns. We `filter()` rows and `select()` columns. 

--

- **Mutate** tables (i.e. add new columns, or re-make existing ones) using `mutate()`.

--

- **Summarize** tables (i.e. perform aggregating calculations) using `summarize()`.

---

# General Social Survey data: .kjh-pink[`gss_sm`]

```{r}
## library(socviz) # if not loaded
gss_sm
```

--

- Notice how the tibble already tells us a lot.

---

# Summarizing a Table

--

- Here's what we're going to do:

.center[![:scale 100%](img/dplyr-pipe-example.png)]

---

# Summarizing a table

```{r}
## Just take a look at the columns we will work on
gss_sm %>% 
  select(id, bigregion, religion)
```

- We're just taking a look at the relevant columns here

---

# Group by .kjh-orange[_one_] column or variable

```{r}

gss_sm %>% 
  group_by(bigregion)
```

- Grouping just changes the logical structure of the tibble

---

`r chunk_reveal("03-dplyr-onecol-summary", widths = c(25,75), title = "# Group and summarize by .kjh-orange[_one_] column")`


```{r 03-dplyr-onecol-summary, include = FALSE}
gss_sm %>% 
  group_by(bigregion) %>% 
  summarize(total = n())
```

--

- The function `n()` counts up the rows within each group.

--

- All the other columns are dropped in the summary operation

--

- Your original .kjh-pink[`gss_sm`] table is untouched

---

`r chunk_reveal("03-dplyr-twocol-summary", widths = c(25,75), title = "# Group and summarize by .kjh-orange[_two_] columns")`


```{r 03-dplyr-twocol-summary, include = FALSE}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  summarize(total = n())
```

--

- The function `n()` counts up the rows within the _innermost_ (i.e. the rightmost) group.

---

`r chunk_reveal("03-dplyr-freq", widths = c(30,70), title = "# Calculate frequencies")`


```{r 03-dplyr-freq, include = FALSE}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  summarize(total = n()) %>% 
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1))
```

--

- The function `n()` counts up the rows 

--

- Which rows? The ones fed down the pipeline

--

- The _innermost_ (i.e. the rightmost) group.

---

# Pipelines carry some assumptions forward

.small[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% #<<
  summarize(total = n()) %>% 
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1))
```
]

- Groups are carried forward till summarized or explicitly ungrouped

--

- Summary calculations are done on the innermost group, which then "disappears". (Notice how it's no longer a group in the output.)

---

# Pipelines carry some assumptions forward

.small[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  summarize(total = n()) %>% 
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1)) #<<
```
]

- `mutate()` is very clever. See how we can immediately use `freq`, even though we are creating it in the same `mutate()` expression.

---

# Convenience functions

.small[

```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% #<<
  summarize(total = n()) %>% #<<
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1)) 
```
]

- We're going to be doing this `group_by()` ... `n()` step a lot. Some shorthand for it would be useful.

---

# Three options for counting up rows

.pull-left-3[

- .SMALL.squish3[Do it yourself]

.SMALL[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% #<<
  summarize(n = n()) #<<
```
]

- .small.squish3[Result is a grouped tibble]
]

--

.pull-middle-3[

- .SMALL.squish3[use `tally()`]

.SMALL[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  tally() #<<
```
]

- .small.squish3[Group it yourself; output is grouped]
]

--

.pull-right-3[

- .SMALL.squish3[use `count()`]

.SMALL[
```{r}
gss_sm %>% 
  count(bigregion, religion) #<<
```
]

- .small.squish3[One step; result is not grouped]
]
