---
title: "Data Wrangling - 3. Manipulating tables with `dplyr`"
author: "Kieran Healy"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    chakra: "../libs/remark-latest.min.js"
    css: ["default", "../css/kjh-slides.css", "../css/kjh-inferno-fonts.css", "../css/animate.css"]
    seal: false
    anchor_sections: false
    nature:
      beforeInit: "../js/kjh-macros.js"
      highlightStyle: default
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
      navigation:
        scroll: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, 
                      fig.retina = 3, fig.align = "center")
```

```{r packages-data, include=FALSE}
library(flipbookr)
library(cowplot)
ggplot2::theme_set(theme_cowplot())

```

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view"))
xaringanExtra::use_animate_css()
xaringanExtra::use_animate_all("fade")
xaringanExtra::use_clipboard()
```

class: center middle main-title section-title-1

# Manipulating Tables with .kjh-yellow[`dplyr`]

.class-info[

**Session 3**

.light[Kieran Healy<br>
Statistical Horizons, April 2021]

]

---

layout: false
class: main-title main-title-inv

# .middle.squish4[Time to<br />play with<br />some .kjh-red[data]]

--

- woohoo!

---

layout: true
class: title title-1

---

# Load our libraries

.SMALL[
```{r, message = TRUE}
library(here)      # manage file paths
library(socviz)    # data and some useful functions
library(tidyverse) # your friend and mine
```
]

---

# Tidyverse components, again

.center[![:scale 100%](img/dplyr_1.png)]

---

# Tidyverse components, again

.center[![:scale 100%](img/dplyr_2.png)]

---

# Other tidyverse components

.center[![:scale 100%](img/dplyr_addnl_1.png)]

---

# Other tidyverse components

.center[![:scale 100%](img/dplyr_addnl_2.png)]


- Not all of these are attached when we do `library(tidyverse)`

---

# .kjh-yellow[dplyr] lets you work with tibbles

- Remember, tibbles are tables of data where the columns can be of different types, such as numeric, logical, character, factor, etc.

--

- We'll use dplyr to _transform_ and _summarize_ our data.

--

- We'll use the pipe operator, **`%>%`**, to chain together sequences of actions on our tables.

--

---

layout: false
class: main-title main-title-inv

# .middle.squish4[`dplyr` draws on the logic and language of  .kjh-green[database queries], where the focus is on manipulating tables]

---

layout: true
class: title title-1

---

# Some .kjh-orange[actions] to take on a single table 

--

- **Group** the data at the level we want, such as “_Religion by Region_” or _“Children by School by District_”, so as to present data at that level.

--

- **Subset** either the rows or columns of or table.

--

- **Mutate**  the data. That is, change something at the _current_ level of grouping.  Mutating adds new columns to the table, or changes the content of an existing column. This won't change the number of rows.

--

- **Summarize** or aggregate the data. That is, make something new at a _higher_ level of grouping. E.g., calculate means or counts by some grouping variable. This will generally result in a smaller, _summary_ table.

---

# Each .kjh-orange[action] has a corresponding .kjh-green[function] 

--

- **Group** using  `group_by()`.

--

- **Subset** has one action for rows and one for columns. We `filter()` rows and `select()` columns. 

--

- **Mutate** tables (i.e. add new columns, or re-make existing ones) using `mutate()`.

--

- **Summarize** tables (i.e. perform aggregating calculations) using `summarize()`.

---

# General Social Survey data: .kjh-pink[`gss_sm`]

```{r}
## library(socviz) # if not loaded
gss_sm
```

--

- Notice how the tibble already tells us a lot.

---

# Summarizing a Table

--

- Here's what we're going to do:

.center[![:scale 100%](img/dplyr-pipe-example.png)]

---

# Summarizing a table

```{r}
## Just take a look at the columns we will work on
gss_sm %>% 
  select(id, bigregion, religion)
```

- We're just taking a look at the relevant columns here

---

# Group by .kjh-orange[_one_] column or variable

```{r}

gss_sm %>% 
  group_by(bigregion)
```

- Grouping just changes the logical structure of the tibble

---

`r chunk_reveal("03-dplyr-onecol-summary", widths = c(25,75), title = "# Group and summarize by .kjh-orange[_one_] column")`


```{r 03-dplyr-onecol-summary, include = FALSE}
gss_sm %>% 
  group_by(bigregion) %>% 
  summarize(total = n())
```

--

- The function `n()` counts up the rows within each group.

--

- All the other columns are dropped in the summary operation

--

- Your original .kjh-pink[`gss_sm`] table is untouched

---

`r chunk_reveal("03-dplyr-twocol-summary", widths = c(25,75), title = "# Group and summarize by .kjh-orange[_two_] columns")`


```{r 03-dplyr-twocol-summary, include = FALSE}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  summarize(total = n())
```

--

- The function `n()` counts up the rows within the _innermost_ (i.e. the rightmost) group.

---

`r chunk_reveal("03-dplyr-freq", widths = c(30,70), title = "# Calculate frequencies")`


```{r 03-dplyr-freq, include = FALSE}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  summarize(total = n()) %>% 
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1))
```

--

- The function `n()` counts up the rows 

--

- Which rows? The ones fed down the pipeline

--

- The _innermost_ (i.e. the rightmost) group.

---

# Pipelines carry some assumptions forward

.small[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% #<<
  summarize(total = n()) %>% 
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1))
```
]

- Groups are carried forward till summarized or explicitly ungrouped

--

- Summary calculations are done on the innermost group, which then "disappears". (Notice how it's no longer a group in the output.)

---

# Pipelines carry some assumptions forward

.small[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  summarize(total = n()) %>% 
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1)) #<<
```
]

- `mutate()` is very clever. See how we can immediately use `freq`, even though we are creating it in the same `mutate()` expression.

---

# Convenience functions

.small[

```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% #<<
  summarize(total = n()) %>% #<<
  mutate(freq = total / sum(total),
           pct = round((freq*100), 1)) 
```
]

- We're going to be doing this `group_by()` ... `n()` step a lot. Some shorthand for it would be useful.

---

# Three options for counting up rows

.pull-left-3[

- .SMALL.squish3[Do it yourself]

.SMALL[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% #<<
  summarize(n = n()) #<<
```
]

- .small.squish3[Result is a grouped tibble]
]

--

.pull-middle-3[

- .SMALL.squish3[use `tally()`]

.SMALL[
```{r}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  tally() #<<
```
]

- .small.squish3[Group it yourself; output is grouped]
]

--

.pull-right-3[

- .SMALL.squish3[use `count()`]

.SMALL[
```{r}
gss_sm %>% 
  count(bigregion, religion) #<<
```
]

- .small.squish3[One step; result is not grouped]
]

---

# Pass your pipeline on to ... a .kjh-yellow[table]

```{r, eval = FALSE}
gss_sm %>% 
  count(bigregion, religion) %>% 
  pivot_wider(names_from = bigregion, values_from = n) %>%  #<<
  kable()  
```


.small[
```{r, echo = FALSE}
gss_sm %>% 
  count(bigregion, religion) %>% 
  pivot_wider(names_from = bigregion, values_from = n) %>% 
  kable()  
```
]

- More on `pivot_wider()` and `kable()` soon ...

---

# Pass your pipeline on to ... a .kjh-yellow[graph]

```{r, echo = FALSE}
theme_set(cowplot::theme_cowplot())
```

.SMALL[
```{r, fig.height=4, fig.width=15}
gss_sm %>% 
  group_by(bigregion, religion) %>% 
  tally() %>% 
  mutate(pct = round((n/sum(n))*100), 1) %>% 
  drop_na() %>% 
  ggplot(mapping = aes(x = pct, y = reorder(religion, -pct), fill = religion)) + 
  geom_col() +
    labs(x = "Percent", y = NULL) +
    guides(fill = FALSE) + 
    facet_wrap(~ bigregion, nrow = 1)
```
]

---

# Pass your pipeline on to ... an .kjh-yellow[object]

.pull-left[
- .SMALL.squish3[You can do it like this ...]
```{r}
rel_by_region <- gss_sm %>% #<<
  count(bigregion, religion) %>% 
  mutate(pct = round((n/sum(n))*100, 1)) 

rel_by_region
```
]

--

.pull-right[

- .SMALL.squish3[Or like this!]
```{r}
gss_sm %>% 
  count(bigregion, religion) %>% 
  mutate(pct = round((n/sum(n))*100, 1)) -> #<<
rel_by_region #<<

rel_by_region
```

]

---

# .kjh-lblue[Right] assignmment is a thing, just like .kjh-red[Left]

.pull-left[

- .kjh-red[Left] assignment is standard

```{r}
gss_tab <- gss_sm %>% 
  count(bigregion, religion) 
```

.left[This may feel awkward with a pipe: "`gss_tab` .kjh-orange[_gets_] the output of the following pipeline."]

]

--

.pull-right[

- .kjh-lblue[Right] assignment also works!

```{r}
gss_sm %>% 
  count(bigregion, religion) -> gss_tab  
  
```

.right[Without any authority, I assert that right-assignment should be read as, e.g., "This pipeline .kjh-orange[_begets_] `gss_tab`"]

]
---

# Pipelined tables can be quickly checked

.pull-left[

```{r}
rel_by_region <- gss_sm %>% 
  count(bigregion, religion) %>% 
  mutate(pct = round((n/sum(n))*100, 1)) 

rel_by_region
```

Hm, did I sum over right group?

]

--
.pull-right[

```{r}
## Each region should sum to ~100
rel_by_region %>% 
  group_by(bigregion) %>% 
  summarize(total = sum(pct)) 

```

No! What has gone wrong here?

]

---

# Pipelined tables can be quickly checked

.pull-left[

```{r}
rel_by_region <- gss_sm %>% 
  count(bigregion, religion) %>% #<< 
  mutate(pct = round((n/sum(n))*100, 1)) 
```

.SMALL.squish3[`count()` returns ungrouped results, so no groups carry forward to the `mutate()` step.]

```{r}
rel_by_region %>% 
  summarize(total = sum(pct))
```

.SMALL.squish3[With `count()`, the `pct` values here are the marginals for the whole table.]

]

--
.pull-right[

```{r}
rel_by_region <- gss_sm %>% 
  group_by(bigregion, religion) %>% #<<
  tally() %>% #<<
  mutate(pct = round((n/sum(n))*100, 1)) 
```

```{r}
# Check
rel_by_region %>% 
  group_by(bigregion) %>% 
  summarize(total = sum(pct))

```

.SMALL.squish3[We get some rounding error because we used `round()` after summing originally.]
]


---

# Two lessons

## Check your tables!

- Pipelines feed their content forward, so you need to make sure your results are not incorrect.

--

- Often, complex tables and graphs can be disturbingly plausible even when wrong.

--

- So, figure out what the result should be and test it!

--

- Starting with simple or toy cases can help with this process.

---

# Two lessons

## Inspect your pipes!

- Understand pipelines by running them forward or peeling them back a step at a time

- This is a _very_ effective way to understand your own and other people's code

---

# Following a pipeline

```{r, echo = FALSE}
theme_set(cowplot::theme_minimal_grid())
```


```{r, fig.height = 4, fig.width=10} 
gss_sm %>% 
  group_by(race, sex, degree) %>% 
  summarize(n = n(), 
            mean_age = mean(age, na.rm = TRUE), 
            mean_kids = mean(childs, na.rm = TRUE)) %>% 
  mutate(pct = n/sum(n)*100) %>% 
  filter(race !="Other") %>% 
  drop_na() %>% 
  ggplot(mapping = aes(x = mean_kids, y = degree)) + 
  geom_col() + facet_grid(sex ~ race) + 
  labs(x = "Average number of Chidren", y = NULL)
```

---

`r chunk_reveal("03-kid-pipeline", widths = c(40,60), title = "# Following a pipeline")`


```{r 03-kid-pipeline, include = FALSE} 
gss_sm %>% 
  group_by(race, sex, degree) %>% 
  summarize(n = n(), 
            mean_age = mean(age, na.rm = TRUE), 
            mean_kids = mean(childs, na.rm = TRUE)) %>% 
  mutate(pct = n/sum(n)*100) %>% 
  filter(race !="Other") %>% 
  drop_na() %>% 
  summarize(grp_totpct = sum(pct))
```

