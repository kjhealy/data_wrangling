---
title: "Data Wrangling - 7. Iterating on data"
author: "Kieran Healy"
date: "`r Sys.Date()`"
output: kjhslides::kjh_slides_reader
editor_options: 
  chunk_output_type: console
---


```{r packages, include=FALSE}
library(flipbookr)
library(here)
library(tidyverse)
library(kjhslides)
```


```{r setup, include=FALSE}

kjh_register_tenso()
kjh_set_knitr_opts()
kjh_set_slide_theme()
kjh_set_xaringan_opts()

```


class: center middle main-title section-title-1

# .kjh-green[Iterating] on data with .kjh-yellow[purrr] and .kjh-yellow[map]  

.class-info[

**Data Wrangling: Session 7**

.light[Kieran Healy<br>
Statistical Horizons, December 2022]

]

---

layout: true
class: title title-1

---

# Load the packages, as always

.SMALL[
```{r 07-iterating-on-data-2, message = TRUE}
library(here)      # manage file paths
library(socviz)    # data and some useful functions
library(tidyverse) # your friend and mine
```
]

---

layout: false
class: center

# .middle.squish4.huge[.kjh-orange[Moar Data]]

---

layout: true
class: title title-1

---

# More than one data file

.SMALL[Inside the `data/` folder of the course packet is a folder named `congress/`]


.smaller[

```{r 07-iterating-on-data-3 }
# A little trick from the fs package: 
fs::dir_tree(here("data", "congress"))
```

]

---

# More than one data file

.SMALL[Let's look at one.]

```{r 07-iterating-on-data-4 }
read_csv(here("data", "congress", "17_95_congress.csv")) |> 
  janitor::clean_names() |> 
  head()
```

We often find ourselves in this situation. We know each file has the same structure, and we would like to use them all at once. 

---

# Loops?

How to read them all in?

One traditional way, which we could do in R, is to write an explicit _loop_ that iterated over a vector of filenames, read each file, and then joined the results together in a tall rectangle.

```r
# Pseudocode

filenames <- c("01_79_congress.csv", "02_80_congress.csv", "03_81_congress.csv",
                "04_82_congress.csv" [etc etc])

collected_files <- NULL

for(i in 1:length(filenames)) {
      new_file <- read_file(filenames[i])
      collected_files <- append_to(collected_files, new_files)
}


```

---

# Loops?

You may have noticed we have not written any loops, however.

While loops are still lurking there underneath the surface, what we will do instead is to take advantage of the combination of vectors and functions and _map_ one to the other in order to generate results.

Speaking loosely, think of .kjh-green[**`map()`**] as a way of .kjh-orange[iterating] without writing loops. You start with a vector of things. You feed it one thing at a time to some function. The function does whatever it does. You get back output that is the same length as your input, and of a specific type.

---

# Mapping is just a kind of iteration

The `purrr` package provides a big family of mapping functions. One reason there are a lot of them is that `purrr`, like the rest of the tidyverse, is picky about data types. 

--

So in addition to the basic .kjh-green[**`map()`**], which always returns a _list_, we also have .kjh-green[**`map_chr()`**], .kjh-green[**`map_int()`**], .kjh-green[**`map_dbl()`**], .kjh-green[**`map_lgl()`**] and others. They always return the data type indicated by their suffix, or die trying.

---

# Vectorized arithmetic again

The simplest cases are not that different from the vectorized arithmetic we're already familiar with. 

```{r 07-iterating-on-data-5 }
a <- c(1:10)

b <- 1

# You know what R will do here
a + b

```

--

R's vectorized rules add `b` to every element of `a`. In a sense, the .kjh-green[**`+`**] operation can be thought of as a function that takes each element of `a` and does something with it. In this case "add `b`".  

---

# Vectorized arithmetic again

We can make this explicit by writing a function:

```{r 07-iterating-on-data-6 }
add_b <- function(x) {
  b <- 1
  x + b # for any x
}
```

Now:

```{r 07-iterating-on-data-7 }
add_b(x = a)
```

---

# Vectorized arithmetic again


Again, R's vectorized approach means it automatically adds `b` to every element of the x we give it.

```{r 07-iterating-on-data-8 }
add_b(x = 10)
```

```{r 07-iterating-on-data-9 }
add_b(x = c(1, 99, 1000))
```

---

# .kjh-green[Iterating] in a pipeline
Some operations can't directly be vectorized in this way, which is why we need to manually iterate, or will want to write loops. 

```{r 07-iterating-on-data-10 }
library(gapminder)
gapminder |> 
  summarize(country_n = n_distinct(country), 
            continent_n = n_distinct(continent), 
            year_n = n_distinct(year), 
            lifeExp_n = n_distinct(lifeExp), 
            population_n = n_distinct(population))
```

That's tedious to write! Computers are supposed to allow us to avoid that sort of thing.

---

# .kjh-green[Iterating] in a pipeline

So how would we iterate this? What we want is to apply the .kjh-green[**`n_distinct()`**] function to each column of `gapminder`, but in a way that still allows us to use pipelines and so on. 

```{r 07-iterating-on-data-11 }
library(gapminder)
gapminder |> 
  summarize(n_distinct(country), 
            n_distinct(continent), 
            n_distinct(year), 
            n_distinct(lifeExp), 
            n_distinct(population))
```

.smaller.kjh-darkgrey[Using .kjh-green[**`n_distinct()`**] in this context is an idea I got from Rebecca Barter's discussion of `purrr`.]

---

# .kjh-green[Iterating] in a pipeline

You'd use .kjh-green[**across()**], like this:

```{r 07-iterating-on-data-12 }
gapminder |> 
  summarize(across(everything(), n_distinct))
```

---

# .kjh-green[Iterating] in a pipeline

But you could also do this ... 

.pull-left[


```{r 07-iterating-on-data-13 }
  map(gapminder, n_distinct)
```

]

.pull-right[
Read it as "Feed each column of `gapminder` to the .kjh-green[**`n_distinct()`**] function.

(This is pretty much what .kjh-green[**`across()`**] is doing more nicely.)
]





---

# .kjh-green[Iterating] in a pipeline

.pull-left[

Or, in pipeline form:

```{r 07-iterating-on-data-14 }
gapminder |> 
  map(n_distinct)
```

]

.pull-right[

You can see we are getting a _list_ back.

]

---

# .kjh-green[Iterating] in a pipeline

Or, in pipeline form:

```{r 07-iterating-on-data-15 }
result <- gapminder |> 
  map(n_distinct)

class(result)

result$continent

result[[2]]
```


---

# .kjh-green[Iterating] in a pipeline

But we know .kjh-green[**`n_distinct()`**] should always return an integer. So we use .kjh-green[**`map_int()`**] instead of the generic .kjh-green[**`map()`**].


```{r 07-iterating-on-data-16 }
gapminder |> 
  map_int(n_distinct)
```

The thing about the .kjh-green[**`map()`**] family is that they can deal with all kinds of input types and output types.

---

# Get a vector of .kjh-pink[filenames]

```{r 07-iterating-on-data-17 }
filenames <- dir(path = here("data", "congress"),
                 pattern = "*.csv",
                 full.names = TRUE)

filenames[1:15] # Just displaying the first 15, to save slide space

```

---

# And feed it to .kjh-green[`read_csv()`]

.small.squish3[... using the variant of .kjh-green[**`map()`**] that returns data frames and tibbles.]

```{r 07-iterating-on-data-18 }
df <- filenames |> 
  map_dfr(read_csv, .id = "congress") |> #<<
  janitor::clean_names()

df
```

---

layout: false
class: center

.top[![:scale 100%](img/emperor-witness.png)]

---

layout: true
class: title title-1

---

# .kjh-green[`read_csv()`] can do this directly now!

No `map_df()` required

```{r 07-iterating-on-data-19 }
tmp <- read_csv(filenames, id = "path",
                name_repair = janitor::make_clean_names)

tmp |> 
  mutate(congress = stringr::str_extract(path, "_\\d{2,3}_congress"), 
         congress = stringr::str_extract(congress, "\\d{2,3}")) |> 
  relocate(congress)

```

---

# Example: Iterating on the .kjh-yellow[US Census]

- But mapped iteration is not just for local files!

```{r 07-iterating-on-data-20 }
## Register for a free Census API key
library(tidycensus)
```

```{r 07-iterating-on-data-21, message=FALSE, results='hide'}
out <- get_acs(geography = "county", 
                    variables = "B19013_001",
                    state = "NY", 
                    county = "New York", 
                    survey = "acs1",
                    year = 2005)
```

```{r 07-iterating-on-data-22}
out
```


---

# Example: Iterating on the .kjh-yellow[US Census]

- All counties in New York State for a specific year

```{r 07-iterating-on-data-23, message=FALSE, results='hide'}
out <- get_acs(geography = "county", 
                    variables = "B19013_001",
                    state = "NY", 
                    survey = "acs1",
                    year = 2005)
```

```{r 07-iterating-on-data-24}
out
```

---

# Example: Iterating on the .kjh-yellow[US Census]

- What if we want the results for _every_ available year?
- First, a handy function: .kjh-green[**`set_names()`**]

```{r 07-iterating-on-data-25, 07-iterating-on-census-3}
x <- c(1:10)

x

x <- set_names(x, nm = letters[1:10])

x
```

---

# Example: Iterating on the .kjh-yellow[US Census]

- By default, .kjh-green[**`set_names()`**] will label a vector with that vector’s values:

```{r 07-iterating-on-data-26, 07-iterating-on-census-4}
c(1:10) |> 
  set_names()

```

---

# Example: Iterating on the .kjh-yellow[US Census]

- Meanwhile, .kjh-green[**`map_dfr()`**] has an `.id` argument that lets you add a
row-identifier to whatever you are binding. Like this:

```{r 07-iterating-on-data-27, message=FALSE, results='hide'}
df <- 2005:2019 |> 
  map_dfr(~ get_acs(geography = "county", 
                    variables = "B19013_001",
                    state = "NY", 
                    county = "New York", 
                    survey = "acs1",
                    year = .x), 
        .id = "id")
```

```{r 07-iterating-on-data-28}
df
```

---

# Example: Iterating on the .kjh-yellow[US Census]

- Our `id` column tracks the year. But we’d like it to *be* the year. So,
we use .kjh-green[**`set_names()`**], and also name it `year` when we create it:


```{r 07-iterating-on-data-29, message=FALSE, results='hide'}
df <- 2005:2019 |> 
  set_names() |> 
  map_dfr(~ get_acs(geography = "county", 
                    variables = "B19013_001",
                    state = "NY", 
                    county = "New York", 
                    survey = "acs1",
                    year = .x), 
        .id = "year") |> 
  mutate(year = as.integer(year))
```

---

# Example: Iterating on the .kjh-yellow[US Census]

```{r 07-iterating-on-data-30}
df
```


- Now `year` is just the year. The `year` column will be created as a
character vector, so we converted it back to an integer again at the end.

---

# Example: Iterating on the .kjh-yellow[US Census]
```{r 07-iterating-on-data-31, message=FALSE, results='hide'}
p_out <- 2005:2019 |> 
  set_names() |> 
  map_dfr(~ get_acs(geography = "county", variables = "B19013_001",
                    state = "NY", survey = "acs1", year = .x), .id = "year") |> 
  mutate(year = as.integer(year)) |> 
  ggplot(mapping = aes(x = year, y = estimate, group = year)) + 
  geom_boxplot(fill = "lightblue", alpha = 0.5, outlier.alpha = 0) + 
  geom_jitter(position = position_jitter(width = 0.1), shape = 1) +
  scale_y_continuous(labels = scales::label_dollar()) + labs(x = "Year", y = "Dollars", 
  title = "Median Household Income by County in New York State, 2005-2019", 
  subtitle = "ACS 1-year estimates", caption = "Data: U.S. Census Bureau.") 

```

---

# Example: Iterating on the .kjh-yellow[US Census]

```{r 07-iterating-on-data-32, fig.width=12, fig.height=5}
print(p_out)
```

---


layout: false
class: center

---


layout: true
class: title title-1

---

# Cleaning up .kjh-yellow[congress]

```{r 07-iterating-on-data-33 }
df <- filenames |> 
  map_dfr(read_csv, .id = "congress") |> #<<
  janitor::clean_names()

df |> 
  select(born, death, start, end)
```

We'll use the **lubridate** package to sort these out. 

Lubridate has a wide range of functions to handle dates, times, and durations. 

???

In particular it has many convenience functions to help with the many different ways that people encode dates that _ought_ to be encoded as `YYYY-MM-DD`.

---

# Cleaning up .kjh-yellow[congress]

```{r 07-iterating-on-data-34 }
library(lubridate)

date_recodes <- c("born", "death", "start", "end")
df <- df |> 
    mutate(across(any_of(date_recodes), mdy), 
           congress = as.double(congress) + 78)

df 

```

---

# Cleaning up .kjh-yellow[congress]

```{r 07-iterating-on-data-35 }
sessions <- tibble(congress = 79:116,
                   start_year = seq(1945, 2019, by = 2),
                   end_year = seq(1947, 2021, by = 2)) |> 
  mutate(start_year = ymd(paste(start_year, "01", "03", sep = "-")), 
         end_year = ymd(paste(end_year, "01", "03", sep = "-")))


sessions

```

---

# We're going to join these tables


.pull-left[

The big table

.SMALL[

```{r 07-iterating-on-data-36 }
df |> 
  select(congress, last, born)

```
]

]

.pull-right[

The smaller table

.SMALL[

```{r 07-iterating-on-data-37 }
sessions

```

]
]

---

# We're going to .kjh-orange[join] these tables

.SMALL.squish3[We will use .kjh-green[**`left_join()`**] which is what you want most of the time when you are looking to merge a smaller table with additional information into a larger main one. ]

.SMALL[

```{r 07-iterating-on-data-38, message = TRUE}

df <- left_join(df, sessions) |> 
  relocate(start_year:end_year, .after = congress)  

df 

```

]

---

# Table joins

.footnote[*Spiffy Join Animatations courtesy [Garrick Aden-Buie](github.com/gadenbuie/join-animations-with-gganimate.R)]

.top[![:scale 35%](img/original-dfs.png)]

---

# Left join, .kjh-yellow[left_join()]

.top[![:scale 35%](img/left-join.gif)]

.SMALL[All rows from x, and all columns from x and y. Rows in x with no match in y will have NA values in the new columns.]

---

# Left join (contd), .kjh-yellow[left_join()]

.top[![:scale 35%](img/left-join-extra.gif)]

.SMALL[If there are multiple matches between x and y, all combinations of the matches are returned.]

---

# Inner join, .kjh-yellow[inner_join()]


.top[![:scale 35%](img/inner-join.gif)]

.SMALL[All rows from x where there are matching values in y, and all columns from x and y.]
---

# Full join, .kjh-yellow[full_join()]

.top[![:scale 35%](img/full-join.gif)]

.SMALL[All rows and all columns from both x and y. Where there are not matching values, returns NA for the one missing.]
---

# Semi join, .kjh-yellow[semi_join()]

.top[![:scale 35%](img/semi-join.gif)]

.SMALL[All rows from x where there are matching values in y, keeping just columns from x.]
---

# Anti join, .kjh-yellow[anti_join()]

.top[![:scale 35%](img/anti-join.gif)]

.SMALL[All rows from x where there are not matching values in y, keeping just columns from x.]
---

# Left join, .kjh-yellow[left_join()]

Most of the time you will be looking to make a .kjh-green[**`left_join()`**]

---

layout: false
class: center

# .middle.squish4.huge[.kjh-red[Missing Data]]

---

layout: true
class: title title-1

---

# Never test for missingness with .kjh-red[`==`]

The result of almost any operation involving a missing/unknown value will be missing/unknown.

```{r 07-iterating-on-data-39 }
df <- tribble(
  ~subject, ~age,
  "A", 20,
  "B", 25,
  "C", NA,
  "D", 34
)

df

```

---

# Never test for missingness with .kjh-red[`==`]

The result of almost any operation involving a missing/unknown value will be missing/unknown.

```{r 07-iterating-on-data-40 }
# OK
df |> 
  filter(age == 25)
```

--

```{r 07-iterating-on-data-41 }
# Nope
df |> 
  filter(age == NA)
```


```{r 07-iterating-on-data-42 }
# E.g.
23 == NA
```


---

# Never test for missingness with .kjh-red[`==`]

Always use .kjh-green[**`is.na()`**] instead

```{r 07-iterating-on-data-43 }
# Yes
df |> 
  filter(is.na(age))
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-44 }
library(naniar)
library(visdat)

organdata
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]


```{r 07-iterating-on-data-45, fig.height=6, fig.width=8}
gg_miss_var(organdata)
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-46, fig.height=6, fig.width=8}
vis_dat(organdata)
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-47, fig.height=6, fig.width=8}
miss_var_summary(organdata)
```


---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-48 }
miss_case_summary(organdata)
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-49 }
organdata |>
  select(consent_law, year, pubhealth, roads) |>
  group_by(consent_law) |>
  miss_var_summary()

```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-50, fig.height=6, fig.width=8}
vis_miss(organdata)
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-51, fig.height=6, fig.width=8}
library(congress)
gg_miss_upset(congress)
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-52, fig.height=6, fig.width=8}
vis_miss(organdata, cluster = TRUE)
```

---

# A quick plug for .kjh-yellow[naniar] and .kjh-yellow[visdat]

```{r 07-iterating-on-data-53, fig.height=6, fig.width=8}
gg_miss_upset(organdata)
```

---

# .kjh-yellow[Upset plots] and a bit of wrangling

![:scale 35%](img/covid-symptoms-venn.jpg)

---

# .kjh-yellow[Upset plots] and a bit of wrangling

```{r 07-iterating-on-data-54 }
symptoms <- c("Anosmia", "Cough", "Fatigue", 
              "Diarrhea", "Breath", "Fever")
names(symptoms) <- symptoms
symptoms
```

---

# .kjh-yellow[Upset plots] and a bit of wrangling

.SMALL[

```{r 07-iterating-on-data-55 }
# An Excel file!
dat <- readxl::read_xlsx(here("data", "symptoms.xlsx")) 
dat |> print(n = nrow(dat))

```

]

---

# .kjh-yellow[Upset plots] and a bit of wrangling

.SMALL[

```{r 07-iterating-on-data-56 }
subsets <- dat |> 
  pull(combination)

## Check if each subset mentions each symptom or not
symptom_mat <- map_dfc(subsets, str_detect, symptoms) |>
    data.frame() |>
    t() |> # transpose the result, this is a little gross, sorry
    as_tibble(.name_repair = "unique")

colnames(symptom_mat) <- symptoms
symptom_mat$count <- dat$count
```

]

---

# .kjh-yellow[Upset plots] and a bit of wrangling

Now we have a table we can do something with.

.SMALL[


```{r 07-iterating-on-data-57 }
symptom_mat |> print(n = nrow(symptom_mat))
```

]
---

# .kjh-yellow[Upset plots] and a bit of wrangling

Uncounting tables

.SMALL[

```{r 07-iterating-on-data-58 }
indvs <- symptom_mat |>
    uncount(count) 

indvs

```

]

Now we've reconstructed the individual-level observations.

---

# .kjh-yellow[Upset plots] and a bit of wrangling


```{r 07-iterating-on-data-59, fig.width=16, fig.height=9, eval = FALSE}
# devtools::install_github("krassowski/complex-upset")

library(ComplexUpset)

upset(data = indvs, intersect = symptoms, 
      name="Symptom Groupings by Frequency. Total pool is 1,764 individuals.", 
      min_size = 0,
      width_ratio = 0.125) +
    labs(title = "Co-Occurence of COVID-19 Symptoms",
         caption = "Data: covid.joinzoe.com/us | Graph: @kjhealy")


```

---

# .kjh-yellow[Upset plots] and a bit of wrangling


```{r 07-iterating-on-data-60, fig.width=12, fig.height=7, echo = FALSE}
# devtools::install_github("krassowski/complex-upset")

library(ComplexUpset)

upset(data = indvs, intersect = symptoms, 
      name="Symptom Groupings by Frequency. Total pool is 1,764 individuals.", 
      min_size = 0,
      width_ratio = 0.125) +
    labs(title = "Co-Occurence of COVID-19 Symptoms",
         caption = "Data: covid.joinzoe.com/us | Graph: @kjhealy")


```

---

layout: false
class: center

# .middle.squish4.huge[.kjh-green[Models]]

---

layout: true
class: title title-1

---

# This is not a .kjh-yellow[statistics] seminar!

I'll just give you an example of the sort of thing that many other modeling packages implement for all kinds of modeling techniques.

Again, the principle is tidy incorporation of models and their output.

---

# Tidy regression output with .kjh-yellow[broom]

```{r 07-iterating-on-data-61 }
library(broom)
library(gapminder)
```


```{r r 07-.kjh-green[Iterating]-2}
out <- lm(formula = lifeExp ~ gdpPercap + pop + continent,
          data = gapminder)
```

---

# Tidy regression output with .kjh-yellow[broom]

We can't _do_ anything with this, programatically.

.SMALL[

```{r r 07-.kjh-green[Iterating]-3}
summary(out)
```

]
---

# Tidy regression output with .kjh-yellow[broom]

```{r r 07-.kjh-green[Iterating]-8}
library(broom)
```

```{r r 07-.kjh-green[Iterating]-9}
tidy(out)
```

That's a _lot_ nicer. Now it's just a tibble. We know those.

---

# Tidy regression output with .kjh-yellow[broom]

.SMALL[

```{r r 07-.kjh-green[Iterating]-11}
out_conf <- tidy(out, conf.int = TRUE)
out_conf 
```

]

---

# Tidy regression output with .kjh-yellow[broom]

.SMALL[

```{r 07-iterating-on-data-62 }
out_conf |>
    filter(term %nin% "(Intercept)") |>
    mutate(nicelabs = prefix_strip(term, "continent")) |>
    select(nicelabs, everything())
```

]

---

# Grouped analysis and .kjh-orange[list columns]

```{r r 07-.kjh-green[Iterating]-20}
eu77 <- gapminder |> filter(continent == "Europe", year == 1977)
fit <- lm(lifeExp ~ log(gdpPercap), data = eu77)
```

.SMALL[

```{r r 07-.kjh-green[Iterating]-21}

summary(fit)
```

]

---

# Grouped analysis and .kjh-orange[list columns]

```{r r 07-.kjh-green[Iterating]-22}

out_le <- gapminder |>
    group_by(continent, year) |>
    nest()

out_le

```

Think of nesting as a kind of "super-grouping". Look in the object inspector.

---

# Grouped analysis and .kjh-orange[list columns]

It's still in there.

```{r r 07-.kjh-green[Iterating]-23}
out_le |> filter(continent == "Europe" & year == 1977) |> 
    unnest(cols = c(data))
```

---

# Grouped analysis and .kjh-orange[list columns]

```{r r 07-.kjh-green[Iterating]-24, echo = FALSE}
old_digits <- getOption("digits")
options(digits = 3)
```

Here we .kjh-green[**`map()`**] a custom function to every row in the `data` column.

```{r r 07-.kjh-green[Iterating]-25}

fit_ols <- function(df) {
    lm(lifeExp ~ log(gdpPercap), data = df)
}

out_le <- gapminder |>
    group_by(continent, year) |>
    nest() |> 
    mutate(model = map(data, fit_ols)) #<<
```

---

# Grouped analysis and .kjh-orange[list columns]


```{r 07-iterating-on-data-63 }
out_le
```


---

# Grouped analysis and .kjh-orange[list columns]

We can tidy the nested models, too.

```{r r 07-.kjh-green[Iterating]-26}

fit_ols <- function(df) {
    lm(lifeExp ~ log(gdpPercap), data = df)
}

out_tidy <- gapminder |>
    group_by(continent, year) |>
    nest() |> 
    mutate(model = map(data, fit_ols),
           tidied = map(model, tidy)) |>
    unnest(cols = c(tidied)) |>
    filter(term %nin% "(Intercept)" &
           continent %nin% "Oceania")
```


---

# Grouped analysis and .kjh-orange[list columns]

```{r 07-iterating-on-data-64 }
out_tidy
```

---

# Grouped analysis and .kjh-orange[list columns]

```{r 07-iterating-on-data-65 }
out_tidy |> 
    ungroup() |>
    sample_n(5)
```


```{r r 07-.kjh-green[Iterating]-27, echo = FALSE}
options(digits = old_digits)
```

