---
title: "Data Wrangling - 6. Reading in data"
author: "Kieran Healy"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    chakra: "../libs/remark-latest.min.js"
    css: ["default", "../css/kjh-slides.css", "../css/kjh-inferno-fonts.css", "../css/animate.css"]
    seal: false
    anchor_sections: false
    nature:
      beforeInit: "../js/kjh-macros.js"
      highlightStyle: default
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
      navigation:
        scroll: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, 
                      fig.retina = 3, fig.align = "center")
```

```{r packages-data, include=FALSE}
library(flipbookr)
library(cowplot)
ggplot2::theme_set(theme_cowplot())

```

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view"))
xaringanExtra::use_animate_css()
xaringanExtra::use_animate_all("fade")
xaringanExtra::use_clipboard()
```

class: center middle main-title section-title-1

# Reading in data with .kjh-yellow[readr] and .kjh-yellow[haven]  

.class-info[

**Session 6**

.light[Kieran Healy<br>
Statistical Horizons, April 2021]

]

---

layout: true
class: title title-1

---

# Load the packages, as always

.SMALL[
```{r, message = TRUE}
library(here)      # manage file paths
library(socviz)    # data and some useful functions
library(tidyverse) # your friend and mine
library(haven)     # for Stata, SAS, and SPSS files
```
]

---

layout: false
class: main-title main-title-inv

# .middle.squish4[.kjh-orange[We've put a lot of pieces in place at this point]]

Including several things we haven't fully exploited yet

---

layout: true
class: title title-1

---

# Data we want to get into R

--

Nice, clean CSV files.

--

More troublesome CSVs.

--

Other plain-text formats.

--

Foreign formats, like Stata.

--


Quite messy things like tables on web pages.

--

... and more besides.

---

# Reading in CSV files

CSV is not really a proper format at all!

--

Base R has `read.csv()`

--

As is often the case, the tidyverse has a corresponding "underscored" version, `read_csv()`.
It is _much_ pickier and more talkative than the Base R version.

???

It's very hazily defined. This makes it surprisingly difficult to parse! Yet is the most common of all plain-text data formats

---

# Where's the data? Using .kjh-yellow[here()]

If we're loading a file, it's coming from _somewhere_.

If it's on our local disk somewhere, we will need to interact with the file system. We should try to do this in a way that avoids _absolute_ file paths. 

```r
# This is not portable
df <- read_csv("/Users/kjhealy/Documents/data/misc/project/data/mydata.csv")
```

--
  
We should also do it in a way that is _platform independent_. 

This makes it easier to share your work, move it around, etc. Projects should be self-contained.

---

# Where's the data? Using .kjh-yellow[here()]

The `here` package, and `here()` function builds paths relative to the top level of your R project. 

```{r}
here() # this path will be different for you
```

---

# Where's the data? Using .kjh-yellow[here()]

This seminar's files all live in an RStudio project. It looks like this:

```{r, echo = FALSE}
fs::dir_tree(here(), recurse = 0)
```

I want to load files from the `data` folder, but I also want _you_ to be able to load them. I'm writing this from somewhere deep in the `slides` folder, but you won't be there. Also, I'm on a Mac, but you may not be.

---

# Where's the data? Using .kjh-yellow[here()]

 So:

```{r}
## Load the file relative to the path from the top of the project, without separators, etc
organs <- read_csv(file = here("data", "organdonation.csv"))
```

--
.SMALL[

```{r}
organs
```

]

.small[And there it is.]

---

# Where's the data? Using .kjh-yellow[here()]

Get in the habit of putting this at the top of your files:

```r
here::i_am("analysis.Rmd") # or whatever your Rmd or R file is called
```

See [the `here` project page](https://here.r-lib.org) for more details.

---

# .kjh-yellow[read_csv()] comes in different varieties


## `read_csv() `Field separator is **`,`**

```{r}
organs <- read_csv(file = here("data", "organdonation.csv"))
```

## `read_csv2()` Field separator is **`,`**

```r
# Example only
my_data <- read_csv2(file = here("data", "my_euro_file.csv))
```

Both are special cases of `read_delim()`

---

# Other species are also catered to

- `read_tsv()` Tab separated.

- `read_fwf()` Fixed-width files.

- `read_log()` Log files (i.e. computer log files).

- `read_lines()` Just read in lines, without trying to parse them.

---

# Also often useful ...

- `read_table()` and `read_table2()` 

Data that's separated by one (or more) columns of space.


---

# You can read files remotely, too

.SMALL.squish3[
You can give all of these functions local files, or they can point to URLs.

Compressed files will be automatically uncompressed.

(Be careful what you download from remote locations!)]

.SMALL[
```{r}
organ_remote <- read_csv("http://kjhealy.co/organdonation.csv")

organ_remote
```
]

---

# An example: .kjh-yellow[read_table()]

.pull-left[
![:scale 100%](img/mortality-top.png)
<br />

![:scale 100%](img/mortality-bottom.png)
]

--

.pull-right[

```{r}
engmort <- read_table(here("data", "mortality.txt"), 
                      skip = 2, na = ".")

engmort
```

]

---

# Pay attention to the .kjh-yellow[column specification]

```{r, message=TRUE}
engmort <- read_table(here("data", "mortality.txt"), 
                      skip = 2, na = ".")

```


The column specification tells you what the read function did. That is, how it interpreted each of the columns. It will also report if things don't go as expected. 

--

Why is `age` imported in `character` format?


---

# Pay attention to the .kjh-yellow[column specification]

Absent you giving them a column specification, the `read_` functions try to _guess_ what the type of each column is. They do this by looking at the first thousand rows of each column. 

They may guess incorrectly!

---

```{r, 06-janitor-pipeline, include = FALSE}
read_table(here("data", "mortality.txt"), 
                      skip = 2, na = ".") %>% 
  janitor::clean_names() %>% 
  mutate(age = as.integer(recode(age, "110+" = "110")))
```

`r chunk_reveal("06-janitor-pipeline", widths = c(40,60), title = "# Normalizing names and recoding")`

--

The `janitor` package is very handy! 

The main cost of normalizing names comes with, e.g., data where there is a codebook you need to consult. But in general it's worth it.

---

# More on column specifications

CDC/NCHS data: [Provisional COVID-19 Death Counts by Sex, Age, and State](https://data.cdc.gov/NCHS/Provisional-COVID-19-Death-Counts-by-Sex-Age-and-S/9bhg-hcku)

![:scale 100%](img/cdc-nchs-sas.png)
---

# More on column specifications

![:scale 90%](img/cdc-nchs-sas-desc.png)

---

# Let's try to load it


```{r, warning = TRUE}
nchs <- read_csv(here("data", "SAS_on_2021-04-13.csv"))
```

---

# Let's try to load it

```{r}
problems(nchs)
```

--

Problems are stored as an attribute of the `nchs` object, so we can revisit them.

--

Parsing failures tend to cascade. Our data only has 56k rows but we got 88k failures.

???

A meta-tibble!

---

# Take a look with .kjh-yellow[head()]

```{r}
head(nchs)
```


---

# Take a look with .kjh-yellow[tail()]

```{r}
tail(nchs)
```

---

# Take a look with .kjh-yellow[slice_sample()]

```{r}
nchs %>% 
  slice_sample(n = 10)
```

---

# Aside: one that happened earlier ...

![:scale 100%](img/slice_sample_why_lgl.png)

???

Month 1!

---

# Take a look with .kjh-yellow[slice()]

Let's look at the rows `read_csv()` complained about.

```{r}
nchs %>% 
  slice(2750:2760) 
```

---

# Take a look with .kjh-yellow[slice()]

```{r}
nchs %>% 
  slice(2750:2760) %>% 
  select(Year, Month, State)
```

Hm, something to do with the transition to national numbers maybe?

---

# Take a look  with .kjh-yellow[select()] and .kjh-yellow[filter()]


```{r}
nchs %>% 
  select(Year, Month, State) %>% 
  filter(State == "New York")

```

---

# Take a look with .kjh-yellow[is.na()]

```{r}
nchs %>% 
  select(Year, Month, State) %>% 
  filter(!is.na(Year)) #<<
```

It really has been read in as a completely empty column.

That doesn't seem like it can be right.

---

# Take a look with .kjh-yellow[distinct()]

```{r}
nchs %>% 
  select(Year) %>% 
  distinct(Year)

```

Again, it's been read in as a completely empty column.

---

# Take a look with .kjh-yellow[read_lines()]

Time to reach for a different kitchen knife.

```{r}
read_lines(here("data", "SAS_on_2021-04-13.csv"), n_max = 10)
```

---

# We can get the whole thing this way

```{r}
raw_file <- read_lines(here("data", "SAS_on_2021-04-13.csv"))
```

This imports the data as a long, long character vector, with each element being a line. 

```{r}
# reminder: indexing 1D vectors
letters[5:6]
```

---

# Now we're just looking at lines in a file

```{r}
# This is not a tibble; we have to index it the basic way
raw_file[2753:2758] 
```

--

There you are, you little bastard.

--

In this case, this is due to the kind of data this is, mixing multiple reporting levels and totals. That is, it's not a mistake in the _data_, but rather in the _parsing_.

---

# OK, let's go back to the colspec!

```{r, message = TRUE}
nchs <- read_csv(here("data", "SAS_on_2021-04-13.csv")) 
```

We can just copy it from the console output! It's valid code.

---

# We use it with .kjh-yellow[col_types]

```r
nchs <- read_csv(here("data", "SAS_on_2021-04-13.csv"), 
           col_types = cols(
  `Data As Of` = col_character(),
  `Start Date` = col_character(),
  `End Date` = col_character(),
  Group = col_character(),
  Year = col_logical(),
  Month = col_logical(),
  State = col_character(),
  Sex = col_character(),
  `Age Group` = col_character(),
  `COVID-19 Deaths` = col_double(),
  `Total Deaths` = col_double(),
  `Pneumonia Deaths` = col_double(),
  `Pneumonia and COVID-19 Deaths` = col_double(),
  `Influenza Deaths` = col_double(),
  `Pneumonia, Influenza, or COVID-19 Deaths` = col_double(),
  Footnote = col_character()
)

```


But we know we need to make some adjustments.

???

Copying a _valid_ colspec is good practice if the underlying data changes!

---

# Fixes

.SMALL[
```{r}
# Date format
us_style <-  "%m/%d/%Y" #<<

nchs <- read_csv(
  here("data", "SAS_on_2021-04-13.csv"),
  col_types = cols(
    `Data As Of` = col_date(format = us_style),#<<
    `Start Date` = col_date(format = us_style),#<<
    `End Date` = col_date(format = us_style),#<<
    Group = col_character(),
    Year = col_character(),#<<
    Month = col_character(),#<<
    State = col_character(),
    Sex = col_character(),
    `Age Group` = col_character(),
    `COVID-19 Deaths` = col_integer(),
    `Total Deaths` = col_integer(),
    `Pneumonia Deaths` = col_integer(),
    `Pneumonia and COVID-19 Deaths` = col_integer(),
    `Influenza Deaths` = col_integer(),
    `Pneumonia, Influenza, or COVID-19 Deaths` = col_integer(),
    Footnote = col_character()
  )) %>% 
  janitor::clean_names() %>% 
  select(-footnote) %>%
  mutate(age_group = stringr::str_to_sentence(age_group)) %>%
  filter(!stringr::str_detect(state, "Total"))
```
]
---

# Now let's look again

```{r}
dim(nchs)

nchs %>% 
  select(year, month, state) %>% 
  filter(!is.na(year)) #<<
```

---

# Now let's look again

```{r}
nchs %>% 
  distinct(year) #<<

```

---

# Lessons learned

--

I said at the start that it was no fun, but also weirdly satisfying.

--

When `read_csv()` warns you of a parsing failure _don't ignore it_.

--

`read_lines()` lets you get the file in a nearly unprocessed form.

--

The `colspec` output is your friend.

---

```{r, echo = FALSE}
nchs_fmt <- nchs %>% 
  select(-year, -month) %>% 
  pivot_longer(covid_19_deaths:pneumonia_influenza_or_covid_19_deaths, 
               names_to = "outcome", 
               values_to = "n") %>% 
  mutate(outcome = str_to_sentence(outcome), 
         outcome = str_replace_all(outcome, "_", " "),
         outcome = str_replace(outcome, "(C|c)ovid 19", "COVID-19"))
```


```{r, nchs-pipeline-02, include=FALSE}
library(stringr) # it's back!

nchs %>% 
  select(!(c(data_as_of:end_date, year, month))) %>% 
  pivot_longer(covid_19_deaths:pneumonia_influenza_or_covid_19_deaths, 
               names_to = "outcome", 
               values_to = "n") %>% 
  mutate(outcome = str_to_sentence(outcome), 
         outcome = str_replace_all(outcome, "_", " "),
         outcome = str_replace(outcome, "(C|c)ovid 19", "COVID-19"))
```

`r chunk_reveal("nchs-pipeline-02", widths = c(50,50), title = "# If we wanted to ...")`


--

Put this in `nchs_fmt`

---

# ... we could make a table or graph

```{r}
nchs_fmt %>% 
  select(state, age_group, outcome, n)
```

---

# Cleaned up (but not tidy)

.pull-left[
```{r}
nchs_fmt %>% 
  distinct(group)
```
]

--

.pull-right[
```{r}
nchs_fmt %>% 
  distinct(age_group)
```
]

---

# Make our plot

```{r}
p_out <- nchs_fmt %>% 
  filter(group %in% "By Total", 
         sex %in% "All Sexes", 
         state %in% "United States", 
         age_group %in% c("0-17 years", 
                          "18-29 years",
                          "30-39 years",
                          "40-49 years",
                          "50-64 years",
                          "65-74 years",
                          "85 years and over"),  
         outcome %in% "COVID-19 deaths") %>%
  mutate(age_group = str_replace(age_group, "years", "yrs"),#<<
         age_group = str_replace(age_group, " and over", ""),#<<
         age_group = str_replace(age_group, "85", "85+")) %>% #<<
  ggplot(mapping = aes(x = n, y = age_group)) +
  geom_col() + scale_x_continuous(labels = scales::comma) + 
  labs(x = "Deaths", y = NULL, title = "U.S. COVID-19 mortality totals by age group")
```

---

# Result

```{r, echo = FALSE}
theme_set(cowplot::theme_minimal_grid())
```


```{r, fig.height=5, fig.width=12}
print(p_out)
```

---

layout: false
class: main-title main-title-inv

# .middle.squish4.huge[.kjh-orange[Every dataset is different]]

---

layout: true
class: title title-1

---

# Dropping .kjh-orange[missing values]: a quick demo

```{r}
df <- tribble(
  ~a, ~b, ~c,
  1, NA, 2,
  NA, NA, NA, 
  2, 2, 2
)

df

```

---

# Dropping .kjh-orange[missing values]: a quick demo

```{r}
# 1 Write it yourself
df %>% 
  filter(complete.cases(.))

# 2 Convenience function
df %>% 
  drop_na()

```

Both drop all rows with _any_ missing cases.

---

# Dropping .kjh-orange[missing values]: a quick demo

What if we only want to drop all rows with _all_ missing cases?

```{r}
# 3
df %>% 
  filter(!(is.na(.))) # Pronoun
```

Read **`.`** as "the thing we're looking at" or "the thing we're computing on right now".

???

This is the kind of thing where you'll find ten different ways online to do it

---

# Cleaning a table

With that in mind ... Some marketing data

![:scale 50%](img/rfm_table.png)

---

```{r, 06-clean-table-pipeline, include = FALSE}

read_csv(here("data", "rfm_table.csv")) %>% 
  janitor::clean_names() %>%
  filter(!(is.na(.))) %>% #<<
  pivot_longer(cols = r:m) %>% 
  separate(col = value, into = c("lo", "hi"), 
           remove = FALSE, convert = TRUE, 
           fill = "left") %>%
  select(-value) %>%
  pivot_wider(names_from = name, 
              values_from = lo:hi) %>%
  mutate_if(is.integer, replace_na, 0) %>%
  select(segment, 
         lo_r, hi_r, 
         lo_f, hi_f, 
         lo_m, hi_m, 
         description)
```

`r chunk_reveal("06-clean-table-pipeline", widths = c(40,60), title = "# Cleaning a table")`

---

# Maybe a candidate for .kjh-yellow[rowwise]?

```{r, echo = FALSE}
rfm_table <- read_csv(here("data", "rfm_table.csv")) %>% 
  janitor::clean_names() %>%
  filter(!(is.na(.))) %>% #<<
  pivot_longer(cols = r:m) %>% 
  separate(col = value, into = c("lo", "hi"), 
           remove = FALSE, convert = TRUE, 
           fill = "left") %>%
  select(-value) %>%
  pivot_wider(names_from = name, 
              values_from = lo:hi) %>%
  mutate_if(is.integer, replace_na, 0) %>%
  select(segment, 
         lo_r, hi_r, 
         lo_f, hi_f, 
         lo_m, hi_m, 
         description)

```

```{r}
rfm_table
```

---

# Maybe a candidate for .kjh-yellow[rowwise]?

This does what we expect:

```{r}
rfm_table %>% 
  mutate(sum_lo = lo_r + lo_f + lo_m,#<<
         sum_hi = hi_r + hi_f + hi_m) %>% #<<
  select(segment, sum_lo, sum_hi, everything())
```

This adds each column, elementwise.

---

# Maybe a candidate for .kjh-yellow[rowwise]?

.squish4[But this does not:]

```{r}
rfm_table %>% 
  mutate(sum_lo = sum(lo_r, lo_f, lo_m),#<<
         sum_hi = sum(hi_r, hi_f, hi_m)) %>%#<< 
  select(segment, sum_lo, sum_hi, everything())


```

.SMALL.squish3[Sum is taking all the columns, adding them up (into a single mumber), and putting that result in each row.]

---

# Maybe a candidate for .kjh-yellow[rowwise]?

Similarly, this will not give the answer we probably expect:

```{r}
rfm_table %>% 
  mutate(mean_lo = mean(c(lo_r, lo_f, lo_m)),#<<
         mean_hi = mean(c(hi_r, hi_f, hi_m))) %>%#<< 
  select(segment, mean_lo, mean_hi, everything())



```

---

# Maybe a candidate for .kjh-yellow[rowwise]?

But this will:

```{r}
rfm_table %>% 
  rowwise() %>% #<<
  mutate(mean_lo = mean(c(lo_r, lo_f, lo_m)),#<<
         mean_hi = mean(c(hi_r, hi_f, hi_m))) %>%#<< 
  select(segment, mean_lo, mean_hi, everything())

```

---

# Rowwise operations aren't very efficient

In general, you'll want to see if some vectorized ("operating on columns, but elementwise") function exists, as it'll be faster. 

And most of the time, R and the tidyverse "wants" you to work in vectorized, columnar terms ... hence your first move will often be to pivot the data into long format. 

So, `rowwise()` is not likely to see a whole lot of further development. 

---

# You probably want `group_by()` instead

```{r}
rfm_table %>% 
  group_by(segment) %>% 
  mutate(mean_lo = mean(c(lo_r, lo_f, lo_m)),#<<
         mean_hi = mean(c(hi_r, hi_f, hi_m))) %>%#<< 
  select(segment, mean_lo, mean_hi, everything())

```

```{r}
rfm_table %>% 
  group_by(segment) %>% 
  mutate(sum_lo = sum(lo_r, lo_f, lo_m),#<<
         sum_hi = sum(hi_r, hi_f, hi_m)) %>%#<< 
  select(segment, sum_lo, sum_hi, everything())

```

---

layout: false
class: main-title main-title-inv

# .middle.squish4[.kjh-orange[What about Stata?]]

---

layout: true
class: title title-1

---

# Using .kjh-green[haven]

